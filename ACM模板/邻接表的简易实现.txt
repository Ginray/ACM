
创建邻接表的代码如下。


//在有的oj上开next数组会报编译错误，因为有oj的库有重名 ，注意！！！！

	
int n,m,i;
//u、v和w的数组大小要根据实际情况来设置，要比m的最大值要大1
int u[6],v[6],w[6];
//first和next的数组大小要根据实际情况来设置，要比n的最大值要大1        
int first[5],next[5];
scanf("%d %d",&n,&m);
//初始化first数组下标1~n的值为-1，表示1~n顶点暂时都没有边
for(i=1;i<=n;i++)
    first[i]=-1;
for(i=1;i<=m;i++)
{
    scanf("%d %d %d",&u[i],&v[i],&w[i]);//读入每一条边
    //下面两句是关键啦
    next[i]=first[u[i]];
    first[u[i]]=i;
}


接下来如何遍历每一条边呢？我们之前说过其实first数组存储的就是每个顶点i（i从1~n）的第一条边。比如1号顶点的第一条边是编号为5的边（1 3 7），2号顶点的第一条边是编号为4的边（2 4 6），3号顶点没有出向边，4号顶点的第一条边是编号为2的边（2 4 6）。那么如何遍历1号顶点的每一条边呢？也很简单。请看下图：


遍历1号顶点所有边的代码如下。

	
k=first[1];// 1号顶点其中的一条边的编号（其实也是最后读入的边）
while(k!=-1) //其余的边都可以在next数组中依次找到
{
    printf("%d %d %d\n",u[k],v[k],w[k]);
    k=next[k];
}


遍历每个顶点的所有边的代码如下。

	
for(i=1;i<=n;i++)
{
    k=first[i];
    while(k!=-1)
    {
        printf("%d %d %d\n",u[k],v[k],w[k]);
        k=next[k];
    }
}


        可以发现使用邻接表来存储图的时间空间复杂度是O(M)，遍历每一条边的时间复杂度是也是O(M)。如果一个图是稀疏图的话，M要远小于N2。因此稀疏图选用邻接表来存储要比邻接矩阵来存储要好很多。